#!/Users/JocieColella/anaconda2/envs/py3/bin/python

__author__ = "JP Colella"
__email__ = "Jocelyn.Colella@unh.edu"

    ### GOALS:
    ### Identify signif sweep sites that are inside genes
    ### if a site is not inside a gene identify the near upstream and downstream gene on EACH strand (+/-, SENSE/ANTISENSE)

import glob
gff_file = "pecr_justsp.gff3"                               ### Generated by 'grepping' the complete annotation (*.functional.gff3): grep "sp|" filename.functional.gff3 > pecr_justsp.gff3
my_output_file = "pecr_signifSweep_geneInfo_4closest.txt"   ### Output file
geneName_outfile = "pecr_signif_4closest_geneNames.txt"     ### Secound output file containing just gene names, to be used as input for PANTHER

### PECR Scaffold names in order of chr assignment (based on mummer results)
scaff_map = ["HiC_scaffold_24", "HiC_scaffold_22", "HiC_scaffold_23", "HiC_scaffold_3", "HiC_scaffold_6", "HiC_scaffold_2", "HiC_scaffold_4", "HiC_scaffold_17", "HiC_scaffold_21", "HiC_scaffold_5", "HiC_scaffold_18", "HiC_scaffold_7", "HiC_scaffold_11", "HiC_scaffold_20", "HiC_scaffold_8", "HiC_scaffold_10", "HiC_scaffold_13", "HiC_scaffold_12", "HiC_scaffold_19", "HiC_scaffold_9", "HiC_scaffold_15", "HiC_scaffold_14", "HiC_scaffold_16", "HiC_scaffold_1"]

### Write header to output file
with open(my_output_file, "w") as outfile:
    outfile.write("chr_name\t scaff_name \t position \t rel_location \t gene_direction \t distance2pos \t GeneName \t SwissProtID \t target_start \t target_stop \n")                               
            
### Get a list of all files in current directory that contain significant selective sweeps (these files are generated from find_nth_percentile_CLRs.py)
list_of_files = []
for signif_file in glob.glob("*_signifCLRs.out"):
    list_of_files.append(signif_file)


### Create a chromosome-scaffold lookup dictionary/map, where the key = CHR: value = SCAFF 
chr_scaff_lookup = {}
for num, scaff in enumerate(scaff_map, start=1):
    chr_scaff_lookup["chr{0}".format(num)] = scaff

### Filter the gff file by lines I want
    ###(e.g. lines that contain an annotated protein and therefore the phrase 'match_part'.
    ### NOTE: this key word may change depending on how MAKER was run or what annotated features you're looking for)
positions = []
gff_line_elements = []
gff_elements = []
with open(gff_file, "r") as gff:
    for gff_line in gff.readlines():
        if 'match_part' in gff_line:
            gff_line_elements = gff_line.split()
            gff_elements.append(gff_line_elements)

### Make lists of items that we're interested in from the maker annotations    
scaff_names = [this_item[0] for this_item in gff_elements]  ### Scaffold names
starts = [int(this_item[3]) for this_item in gff_elements]  ### list of tuples
stops = [int(this_item[4]) for this_item in gff_elements]   ### list of tuples
dirs = [this_item[6] for this_item in gff_elements]         ### '+' or '-' direction

### Create a +/forward/sense dictionary, with scaffold name keys and (start,stop) annotations as values
rev_dict = {}
fwd_dict = {}
for this_scaff_name,this_start,this_stop,this_dir,this_line in zip(scaff_names, starts, stops, dirs, gff_elements):
    ### Add '+' and '-' as dictionary keys
    if this_dir == '+':
        fwd_dict.setdefault(this_scaff_name, {})
        gene_interval=tuple([this_start, this_stop]) ### Add (start,stop) key to the '+' value
        fwd_dict[this_scaff_name][gene_interval] = this_line
    else: 
        rev_dict.setdefault(this_scaff_name, {})
        gene_interval=tuple([this_start, this_stop])
        rev_dict[this_scaff_name][gene_interval] = this_line

### Determine if each significant site/position is INSIDE of a protein coding gene (e.g., lies between the start and stop positions of that annotated feature)
swissprot_ID_list = []
pos_not_in_genes = {}
all_genes = set()
### Identify all the significant positions/sweepsites that are INSIDE and writ those data to an output file while building a list of positions/sweepsites NOT inside protein coding genes
for filename in list_of_files: ### Sweepfinder output files with significant positions
    with open(filename, "r") as this_infile:
        chr_name = filename.split("_")[0]               ### Extract chromosome name from the first part of the file name (delimited by an underscore) and use that string to look up the corresponding scaffold name from the chr_scaff_lookup dictionary
        this_scaff_name = chr_scaff_lookup[chr_name]
        inner_fwd_dict = fwd_dict[this_scaff_name]      ### add each scaffold name to dict as a key, with another dict as value
        inner_rev_dict = rev_dict[this_scaff_name]      ### add each scaffold name to dict as a key, with another dict as value
        
        ### Loop over all of significant positions/lines in the file (which contains ONLY significant outputs from SweepFinder2
        for line in this_infile:
            found_in_gene = False
            test_pos = line.split()[0]
            pos = int(test_pos.split('.')[0])
        
        ### Loop through all (start,stop) intervals on the +/forward/sense strand to determine if the sweepsite/position is in a protein coding gene
        #if found_in_gene == False:
            for each_fwd_interval_key in inner_fwd_dict.keys():
                fwd_key_start = each_fwd_interval_key[0]
                fwd_key_stop = each_fwd_interval_key[1]
                
                ### Grab line data (e.g., the list of line elements) that correspond to the (start,stop) interval we're working with 
                this_data_line = fwd_dict[this_scaff_name][each_fwd_interval_key]
                annotation = this_data_line[8:]
                ID = ';'.join(annotation)
                target = ID.split("Target=")[-1]
                direction = this_data_line[6]

                ### To accomodate inconsistencies in target naming in the gff file:
                    ### Some annotations are named in this format: gi|130640|sp|P08361|POL_MLVCB
                    ### Others are named in this format: sp|D3Z690|IZUM4_MOUSE 
                target_parts = target.split("|")
                if len(target_parts) == 3:
                    swissprot_ID = target_parts[1]
                    gene_name = target_parts[2].split(";")[0]
                else:
                    swissprot_ID = target_parts[3]
                    gene_name = target_parts[4].split(";")[0]
                all_genes.add(gene_name)
                
                ### Test if the position is in a gene (between the start and stop positions of a gene) on the -/reverse/antisense strand
                if fwd_key_start <= pos and pos <= fwd_key_stop:
                    print("{0} IS IN A + GENE, interval: {1} {2}".format(pos, fwd_key_start, fwd_key_stop))
                    with open(my_output_file, "a") as outfile:
                                #"chr_name\t scaff_name \t position \t (REL_location) \t gene_direction \t distance2pos \t target \t SwissProtID \t target_start \t target_stop \n")  
                        outfile.write("{0}\t {1} \t {2} \t GENE \t {3} \t {4} \t 0 \t {5} \t {6} \t {7}\n".format(chr_name, this_scaff_name, pos, direction, gene_name, swissprot_ID, fwd_key_start, fwd_key_stop))               
                        outfile.close()
                    
                    ### Write gene name to separate file for use in PANTHER enrichment analysis
                    with open(geneName_outfile, "a") as outfile:
                        outfile.write("{0}\n".format(gene_name))                   
                        outfile.close()
                    found_in_gene = True
                
        ### Loop through all (start, stop) intervals on the -/negative/antisense strand and determine if the sweepsite/poisition lies inside a protein coding gene
            for each_rev_interval_key in inner_rev_dict.keys():
                rev_key_start = each_rev_interval_key[0]
                rev_key_stop = each_rev_interval_key[1]
            
                ### Grab line data (e.g., the list of line elements) that correspond to the (start,stop) interval we're working with 
                this_data_line = rev_dict[this_scaff_name][each_rev_interval_key]
                annotation = this_data_line[8:]
                ID = ';'.join(annotation)
                target = ID.split("Target=")[-1]
                direction = this_data_line[6]

                ### To accomodate inconsistencies in target naming in the gff file:
                target_parts = target.split("|")
                if len(target_parts) == 3:
                    swissprot_ID = target_parts[1]
                    gene_name = target_parts[2].split(";")[0]
                else:
                    swissprot_ID = target_parts[3]
                    gene_name = target_parts[4].split(";")[0]
                all_genes.add(gene_name)

                ### Test if the position is in a gene (between the start and stop positions of a gene) on the -/reverse/antisense strand
                if rev_key_start <= pos and pos <= rev_key_stop: #IT's in a fwd gene
                    print("{0} IS IN A - GENE, interval: {1} {2}".format(pos, rev_key_start, rev_key_stop))
                    with open(my_output_file, "a") as outfile: 
                        outfile.write("{0}\t {1} \t {2} \t GENE \t {3} \t {4} \t 0 \t {5} \t {6} \t {7}\n".format(chr_name, this_scaff_name, pos, direction, gene_name, swissprot_ID, rev_key_start, rev_key_stop)) 
                        outfile.close()
                    
                    ### Write gene name to separate file for use in PANTHER enrichment analysis
                    with open(geneName_outfile, "a") as outfile:
                        outfile.write("{0}\n".format(gene_name))                   
                        outfile.close()
                    found_in_gene = True ### Set a boolean to True if the sweepsite/position was found in a gene
            
            ### Otherwise, if the position/sweep site is NOT found in a gene, add it to a new dictionary, intuitively called pos_not_in_genes
            if not found_in_gene:
                pos_not_in_genes.setdefault(chr_name, [])
                pos_not_in_genes[chr_name].append(pos)


### Now, for positions NOT located within a protein coding gene (e.g., most)
### Find the nearest gene upstream and downstream (on both the +/forward/sense and -/reverse/antisense strands) - 4 genes total
### And calculate the distance to that locus
for chr_name in pos_not_in_genes:
    this_scaff_name = chr_scaff_lookup[chr_name]
        
    for pos in pos_not_in_genes[chr_name]:
        ### Initialize "winners" before assessing each position (these numbers are intentionally unrealistically high so that they are replaced by shorter/smaller gene-to-sweepsite distances)
        fwd_upstream_winner_dist = 50000000000
        fwd_upstream_key_winner = tuple()
        fwd_downstream_winner_dist = 50000000000
        fwd_downstream_key_winner = tuple()

        rev_upstream_winner_dist = 50000000000
        rev_upstream_key_winner = tuple()
        rev_downstream_winner_dist = 50000000000
        rev_downstream_key_winner = tuple()
        
        ### Loop through each (start,stop) interval on the -/reveser/antisense strand and calculate closest 'winner' genes
        for each_fwd_interval_key in fwd_dict[this_scaff_name]:
            fwd_key_start = each_fwd_interval_key[0]
            fwd_key_stop = each_fwd_interval_key[1]
                
            ### Grab the line data (e.g., list of line elements) that corresponds to the start/stop interval we're working with (e.g., inner_dict_key)
            this_data_line = fwd_dict[this_scaff_name][each_fwd_interval_key]
            annotation = this_data_line[8:]
            ID = ';'.join(annotation)
            target = ID.split("Target=")[-1]
            direction = this_data_line[6]

            ### To accomodate inconsistencies in target naming (as in above loop)
            target_parts = target.split("|")
            if len(target_parts) == 3:
                swissprot_ID = target_parts[1]
                gene_name = target_parts[2].split(";")[0]
            else:
                swissprot_ID = target_parts[3]
                gene_name = target_parts[4].split(";")[0]
            all_genes.add(gene_name)
        
            ### Find the nearest gene to the LEFT of the current position/sweepsite (pos)
                ### e.g., Find the closest STOP interval (e.g., gene) upstream of the current position/sweepsite (pos) on the +/forward/sense strand
            if pos - fwd_key_stop  < fwd_upstream_winner_dist and pos > fwd_key_stop: #if smaller distance to this gene, update winner distance and interval key
                fwd_upstream_winner_dist = pos - fwd_key_stop
                fwd_upstream_key_winner = each_fwd_interval_key
                fwd_upstream_gene_name = gene_name
                
            ### Find the nearest gene to the RIGHT of the current position/sweepsite (pos)
                ### Find the closest START interval (e.g., gene) downstream of the current position/sweepsite (pos) on the +/forward/sense strand
            if fwd_key_start - pos < fwd_downstream_winner_dist and pos < fwd_key_start: #if smaller distance to this gene, update winner distance and interval key
                fwd_downstream_winner_dist = fwd_key_start - pos
                fwd_downstream_key_winner = each_fwd_interval_key
                fwd_downstream_gene_name = gene_name
          
        ### Write to output file:   
        with open(my_output_file, "a") as outfile: 
            outfile.write("{0}\t {1} \t {2} \t fwd_upstream \t {3} \t {4} \t {5} \t {6} \t {7}\n".format(chr_name, this_scaff_name, pos, direction, fwd_upstream_gene_name, fwd_upstream_winner_dist, swissprot_ID, fwd_upstream_key_winner))               
            outfile.close()
        with open(my_output_file, "a") as outfile: 
            outfile.write("{0}\t {1} \t {2} \t fwd_downstream \t {3} \t {4} \t {5} \t {6} \t {7}\n".format(chr_name, this_scaff_name, pos, direction, fwd_downstream_gene_name, fwd_downstream_winner_dist, swissprot_ID, fwd_downstream_key_winner))               
            outfile.close()

        ### Loop through each (start,stop) interval on the -/reverse/antisense strand and calculate closest 'winner' genes
        for each_rev_interval_key in rev_dict[this_scaff_name]:
            rev_key_start = each_rev_interval_key[0]
            rev_key_stop = each_rev_interval_key[1]
                
            ### Grab the line data (e.g., list of line elements) that corresponds to the start/stop interval we're working with (e.g., inner_dict_key)
            this_data_line = rev_dict[this_scaff_name][each_rev_interval_key]
            annotation = this_data_line[8:]
            ID = ';'.join(annotation)
            target = ID.split("Target=")[-1]
            direction = this_data_line[6]

            # To accomodate inconsistencies in target naming (as in above loop)
            target_parts = target.split("|")
            if len(target_parts) == 3:
                swissprot_ID = target_parts[1]
                gene_name = target_parts[2].split(";")[0]
            else:
                swissprot_ID = target_parts[3]
                gene_name = target_parts[4].split(";")[0]
            all_genes.add(gene_name)
        
            ### Find the nearest gene to the LEFT of the current position/sweepsite (pos)
                ### e.g., Find the closest STOP interval (e.g., gene) upstream of the current position/sweepsite (pos) on the -/reverse/antisense strand
            if pos - rev_key_stop < rev_upstream_winner_dist and pos > rev_key_stop: #if smaller distance to this gene, update winner distance and interval key
                rev_upstream_winner_dist = pos - rev_key_stop
                rev_upstream_key_winner = each_rev_interval_key
                rev_upstream_gene_name = gene_name

            ### Find the nearest gene to the RIGHT of the current position/sweepsite (pos)
                ### Find the closest START interval (e.g., gene) downstream of the current position/sweepsite (pos) on the -/reverse/antisense strand
            if rev_key_start - pos < rev_downstream_winner_dist and pos < rev_key_start: #if smaller distance to this gene, update winner distance and interval key
                rev_downstream_winner_dist = rev_key_start - pos
                rev_downstream_key_winner = each_rev_interval_key
                rev_downstream_gene_name = gene_name
        
        ### Write to output files
        with open(my_output_file, "a") as outfile: 
            outfile.write("{0}\t {1} \t {2} \t rev_downstream \t {3} \t {4} \t {5} \t {6} \t {7}\n".format(chr_name, this_scaff_name, pos, direction, rev_downstream_gene_name , rev_upstream_winner_dist, swissprot_ID, rev_upstream_key_winner))
            outfile.close()       
        with open(my_output_file, "a") as outfile: 
            outfile.write("{0}\t {1} \t {2} \t rev_upstream \t {3} \t {4} \t {5} \t {6} \t {7}\n".format(chr_name, this_scaff_name, pos, direction, rev_upstream_gene_name , rev_downstream_winner_dist, swissprot_ID, rev_downstream_key_winner))               
            outfile.close()

### Write unique gene names to second output file for use in PANTHER enrichment analysis
with open(geneName_outfile, "w") as outfile:
    for gene in all_genes:
        outfile.write("{0}\n".format(gene))                   
outfile.close()
    
